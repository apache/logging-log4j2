/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache license, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the license for the specific language governing permissions and
 * limitations under the license.
 */
package org.apache.logging.log4j.internal.util.changelog.exporter;

import org.apache.logging.log4j.internal.util.changelog.ChangelogEntry;
import org.apache.logging.log4j.internal.util.changelog.ChangelogFiles;
import org.apache.logging.log4j.internal.util.changelog.ChangelogRelease;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.nio.file.attribute.FileTime;
import java.util.Comparator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public final class AsciiDocExporter {

    private static final String TARGET_RELATIVE_DIRECTORY = "src/site/asciidoc/changelog";

    private static final Comparator<Path> FILE_MODIFICATION_TIME_COMPARATOR = Comparator.comparing(path -> {
        try {
            final FileTime fileTime = Files.getLastModifiedTime(path);
            return fileTime.toMillis();
        } catch (final IOException error) {
            final String message = String.format("failed reading the last-modified time: `%s`", path);
            throw new UncheckedIOException(message, error);
        }
    });

    private static final String LICENSE_HEADER_ASCIIDOC = "////\n" +
            "    Licensed to the Apache Software Foundation (ASF) under one or more\n" +
            "    contributor license agreements.  See the NOTICE file distributed with\n" +
            "    this work for additional information regarding copyright ownership.\n" +
            "    The ASF licenses this file to You under the Apache License, Version 2.0\n" +
            "    (the \"License\"); you may not use this file except in compliance with\n" +
            "    the License.  You may obtain a copy of the License at\n" +
            "\n" +
            "         https://www.apache.org/licenses/LICENSE-2.0\n" +
            "\n" +
            "    Unless required by applicable law or agreed to in writing, software\n" +
            "    distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
            "    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
            "    See the License for the specific language governing permissions and\n" +
            "    limitations under the License.\n" +
            "////\n";

    private static final String AUTO_GENERATION_WARNING_ASCIIDOC = "////\n" +
            "*DO NOT EDIT THIS FILE!!*\n" +
            "This file is automatically generated from the release changelog directory!\n" +
            "////\n";

    private AsciiDocExporter() {}

    public static void main(final String[] mainArgs) {

        // Read arguments.
        final AsciiDocExporterArgs args = AsciiDocExporterArgs.fromMainArgs(mainArgs);

        // Find release directories.
        final Path changelogDirectory = ChangelogFiles.changelogDirectory(args.projectRootDirectory);
        final List<Path> releaseDirectories = findAdjacentFiles(changelogDirectory)
                .sorted()
                .collect(Collectors.toList());
        final int releaseDirectoryCount = releaseDirectories.size();

        // Read the release information files.
        final List<ChangelogRelease> changelogReleases = releaseDirectories
                .stream()
                .map(releaseDirectory -> {
                    final Path releaseXmlFile = ChangelogFiles.releaseXmlFile(releaseDirectory);
                    return ChangelogRelease.readFromXmlFile(releaseXmlFile);
                })
                .collect(Collectors.toList());

        // Export releases.
        if (releaseDirectoryCount > 0) {

            // Export each release directory.
            for (int releaseIndex = 0; releaseIndex < releaseDirectories.size(); releaseIndex++) {
                final Path releaseDirectory = releaseDirectories.get(releaseIndex);
                final ChangelogRelease changelogRelease = changelogReleases.get(releaseIndex);
                try {
                    exportRelease(args.projectRootDirectory, releaseDirectory, changelogRelease);
                } catch (final Exception error) {
                    final String message =
                            String.format("failed exporting release from directory `%s`", releaseDirectory);
                    throw new RuntimeException(message, error);
                }
            }

            // Report the operation.
            if (releaseDirectoryCount == 1) {
                System.out.format("exported a single release directory: `%s`%n", releaseDirectories.get(0));
            } else {
                System.out.format(
                        "exported %d release directories: ..., `%s`%n",
                        releaseDirectories.size(),
                        releaseDirectories.get(releaseDirectoryCount - 1));
            }

        }

        // Export the release index.
        exportReleaseIndex(args.projectRootDirectory, changelogReleases);

    }

    /**
     * Finds files non-recursively in the given directory.
     * <p>
     * Given directory itself and hidden files are filtered out.
     * </p>
     */
    @SuppressWarnings("RedundantIfStatement")
    private static Stream<Path> findAdjacentFiles(final Path directory) {
        try {
            return Files
                    .walk(directory, 1)
                    .filter(path -> {

                        // Skip the directory itself.
                        if (path.equals(directory)) {
                            return false;
                        }

                        // Skip hidden files.
                        boolean hiddenFile = path.getFileName().toString().startsWith(".");
                        if (hiddenFile) {
                            return false;
                        }

                        // Accept the rest.
                        return true;

                    });
        } catch (final IOException error) {
            final String message = String.format("failed walking directory: `%s`", directory);
            throw new UncheckedIOException(message, error);
        }
    }

    private static void exportRelease(
            final Path projectRootDirectory,
            final Path releaseDirectory,
            final ChangelogRelease changelogRelease) {

        // Read the changelog intro.
        final String introAsciiDoc = readIntroAsciiDoc(releaseDirectory);

        // Read the changelog entries.
        final List<ChangelogEntry> changelogEntries = findAdjacentFiles(releaseDirectory)
                .sorted(FILE_MODIFICATION_TIME_COMPARATOR)
                .map(ChangelogEntry::readFromXmlFile)
                .collect(Collectors.toList());

        // Export the release.
        try {
            exportRelease(projectRootDirectory, changelogRelease, introAsciiDoc, changelogEntries);
        } catch (final IOException error) {
            final String message = String.format("failed exporting release from directory `%s`", releaseDirectory);
            throw new UncheckedIOException(message, error);
        }

    }

    private static String readIntroAsciiDoc(final Path releaseDirectory) {
        final Path introAsciiDocFile = ChangelogFiles.introAsciiDocFile(releaseDirectory);
        if (!Files.exists(introAsciiDocFile)) {
            return "";
        }
        final byte[] introAsciiDocBytes;
        try {
            introAsciiDocBytes = Files.readAllBytes(introAsciiDocFile);
        } catch (final IOException error) {
            final String message = String.format("failed reading intro AsciiDoc file: `%s`", introAsciiDocFile);
            throw new UncheckedIOException(message, error);
        }
        return new String(introAsciiDocBytes, StandardCharsets.UTF_8);
    }

    private static void exportRelease(
            final Path projectRootDirectory,
            final ChangelogRelease release,
            final String introAsciiDoc,
            final List<ChangelogEntry> entries)
            throws IOException {
        final String asciiDocFilename = changelogReleaseAsciiDocFilename(release);
        final Path asciiDocFile = projectRootDirectory
                .resolve(TARGET_RELATIVE_DIRECTORY)
                .resolve(asciiDocFilename);
        Files.createDirectories(asciiDocFile.getParent());
        final String asciiDoc = exportReleaseToAsciiDoc(release, introAsciiDoc, entries);
        final byte[] asciiDocBytes = asciiDoc.getBytes(StandardCharsets.UTF_8);
        Files.write(asciiDocFile, asciiDocBytes, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
    }

    private static String exportReleaseToAsciiDoc(
            final ChangelogRelease release,
            final String introAsciiDoc,
            final List<ChangelogEntry> entries) {

        // Write the header.
        final StringBuilder stringBuilder = new StringBuilder();
        stringBuilder
                .append(LICENSE_HEADER_ASCIIDOC)
                .append('\n')
                .append(AUTO_GENERATION_WARNING_ASCIIDOC)
                .append('\n')
                .append("= ")
                .append(release.version)
                .append(" (")
                .append(release.date)
                .append(")\n")
                .append(introAsciiDoc)
                .append("\n");

        if (!entries.isEmpty()) {

            stringBuilder.append("== Changes\n");

            // Group entries by type.
            final Map<ChangelogEntry.Type, List<ChangelogEntry>> entriesByType = entries
                    .stream()
                    .collect(Collectors.groupingBy(changelogEntry -> changelogEntry.type));

            // Write entries for each type.
            entriesByType
                    .keySet()
                    .stream()
                    // Sorting is necessary for a consistent layout across different runs.
                    .sorted()
                    .forEach(type -> {
                        stringBuilder.append('\n');
                        appendEntryTypeHeader(stringBuilder, type);
                        entriesByType.get(type).forEach(entry -> appendEntry(stringBuilder, entry));
                    });

        }

        // Return the accumulated document so far.
        return stringBuilder.toString();

    }

    private static void appendEntryTypeHeader(final StringBuilder stringBuilder, final ChangelogEntry.Type type) {
        final String typeName = type.toString().toLowerCase(Locale.US);
        final String header = typeName.substring(0, 1).toUpperCase(Locale.US) + typeName.substring(1);
        stringBuilder
                .append("=== ")
                .append(header)
                .append("\n\n");
    }

    private static void appendEntry(final StringBuilder stringBuilder, final ChangelogEntry entry) {
        stringBuilder.append("* ");
        appendEntryDescription(stringBuilder, entry.description);
        final boolean containingIssues = !entry.issues.isEmpty();
        final boolean containingAuthors = !entry.authors.isEmpty();
        if (containingIssues || containingAuthors) {
            stringBuilder.append(" (");
            if (containingIssues) {
                appendEntryIssues(stringBuilder, entry.issues);
            }
            if (containingIssues && containingAuthors) {
                stringBuilder.append(' ');
            }
            if (containingAuthors) {
                appendEntryAuthors(stringBuilder, entry.authors);
            }
            stringBuilder.append(")");
        }
        stringBuilder.append('\n');
    }

    private static void appendEntryDescription(
            final StringBuilder stringBuilder,
            final ChangelogEntry.Description description) {
        if (!"asciidoc".equals(description.format)) {
            final String message = String.format("unsupported description format: `%s`", description.format);
            throw new RuntimeException(message);
        }
        stringBuilder.append(description.text);
    }

    private static void appendEntryIssues(
            final StringBuilder stringBuilder,
            final List<ChangelogEntry.Issue> issues) {
        stringBuilder.append("for ");
        final int issueCount = issues.size();
        for (int issueIndex = 0; issueIndex < issueCount; issueIndex++) {
            final ChangelogEntry.Issue issue = issues.get(issueIndex);
            appendEntryIssue(stringBuilder, issue);
            if ((issueIndex + 1) != issueCount) {
                stringBuilder.append(", ");
            }
        }
    }

    private static void appendEntryIssue(final StringBuilder stringBuilder, final ChangelogEntry.Issue issue) {
        stringBuilder
                .append(issue.link)
                .append('[')
                .append(issue.id)
                .append(']');
    }

    private static void appendEntryAuthors(
            final StringBuilder stringBuilder,
            final List<ChangelogEntry.Author> authors) {
        stringBuilder.append("by ");
        final int authorCount = authors.size();
        for (int authorIndex = 0; authorIndex < authors.size(); authorIndex++) {
            final ChangelogEntry.Author author = authors.get(authorIndex);
            appendEntryAuthor(stringBuilder, author);
            if ((authorIndex + 1) != authorCount) {
                stringBuilder.append(", ");
            }
        }
    }

    private static void appendEntryAuthor(final StringBuilder stringBuilder, final ChangelogEntry.Author author) {
        if (author.id != null) {
            stringBuilder
                    .append('`')
                    .append(author.id)
                    .append('`');
        } else {
            // Normalize author names written in `Doe, John` form.
            if (author.name.contains(",")) {
                String[] nameFields = author.name.split(",", 2);
                stringBuilder.append(nameFields[1].trim());
                stringBuilder.append(nameFields[0].trim());
            } else {
                stringBuilder.append(author.name);
            }
        }
    }

    private static void exportReleaseIndex(
            final Path projectRootDirectory,
            final List<ChangelogRelease> changelogReleases) {
        final String asciiDoc = exportReleaseIndexToAsciiDoc(changelogReleases);
        final byte[] asciiDocBytes = asciiDoc.getBytes(StandardCharsets.UTF_8);
        final Path asciiDocFile = projectRootDirectory.resolve(TARGET_RELATIVE_DIRECTORY).resolve("index.adoc");
        try {
            Files.write(asciiDocFile, asciiDocBytes);
        } catch (final IOException error) {
            throw new UncheckedIOException(error);
        }
    }

    private static String exportReleaseIndexToAsciiDoc(final List<ChangelogRelease> changelogReleases) {
        final StringBuilder stringBuilder = new StringBuilder();
        stringBuilder
                .append(LICENSE_HEADER_ASCIIDOC)
                .append('\n')
                .append(AUTO_GENERATION_WARNING_ASCIIDOC)
                .append("\n= Release changelogs\n\n");
        for (int releaseIndex = changelogReleases.size() - 1; releaseIndex >= 0; releaseIndex--) {
            final ChangelogRelease changelogRelease = changelogReleases.get(releaseIndex);
            final String asciiDocFilename = changelogReleaseAsciiDocFilename(changelogRelease);
            final String asciiDocBullet = String.format(
                    "* [%s] xref:%s[%s]\n",
                    changelogRelease.date,
                    asciiDocFilename,
                    changelogRelease.version);
            stringBuilder.append(asciiDocBullet);
        }
        return stringBuilder.toString();
    }

    private static String changelogReleaseAsciiDocFilename(final ChangelogRelease changelogRelease) {
        // Using only the version (that is, avoiding the date) in the filename so that one can determine the link to the changelog of a particular release with only version information.
        return String.format("%s.adoc", changelogRelease.version);
    }

}
